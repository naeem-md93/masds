{".gitignore": {"type": "text-file", "note": "", "contents": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# Snowpack dependency directory (https://snowpack.dev/)\nweb_modules/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional stylelint cache\n.stylelintcache\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variable files\n.env\n.env.*\n!.env.example\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n.parcel-cache\n\n# Next.js build output\n.next\nout\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and not Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# vuepress v2.x temp and cache directory\n.temp\n.cache\n\n# Sveltekit cache directory\n.svelte-kit/\n\n# vitepress build output\n**/.vitepress/dist\n\n# vitepress cache directory\n**/.vitepress/cache\n\n# Docusaurus cache and generated files\n.docusaurus\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# Firebase cache directory\n.firebase/\n\n# TernJS port file\n.tern-port\n\n# Stores VSCode versions used for testing VSCode extensions\n.vscode-test\n\n# yarn v3\n.pnp.*\n.yarn/*\n!.yarn/patches\n!.yarn/plugins\n!.yarn/releases\n!.yarn/sdks\n!.yarn/versions\n\n# Vite logs files\nvite.config.js.timestamp-*\nvite.config.ts.timestamp-*\n\n# Package\npackage-lock.json\npackage.json.bak\npackage.tmp\n"}, "package.json": {"type": "text-file", "note": "", "contents": "{\n  \"name\": \"founderise\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"type\": \"commonjs\",\n  \"dependencies\": {\n    \"body-parser\": \"^2.2.0\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^17.2.1\",\n    \"express\": \"^5.1.0\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"mysql2\": \"^3.14.2\",\n    \"sequelize\": \"^6.37.7\",\n    \"sequelize-cli\": \"^6.6.3\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.1.10\"\n  }\n}\n"}, "src": {"type": "directory", "note": "", "contents": ["frontend", "microservices", "middleware"]}, "src/frontend": {"type": "directory", "note": "", "contents": ["index.html", "pages", "assets"]}, "src/frontend/index.html": {"type": "text-file", "note": "", "contents": "<!DOCTYPE html>\n<html lang='en'>\n<head>\n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Chatbot Frontend</title>\n</head>\n<body>\n    <h1>Chatbot Frontend Placeholder</h1>\n</body>\n</html>\n"}, "src/frontend/pages": {"type": "directory", "note": "", "contents": ["AuthPage.js", "ConversationPage.js", "ConversationPage.js.bak"]}, "src/frontend/pages/AuthPage.js": {"type": "text-file", "note": "", "contents": "import React from 'react';\n\nconst AuthPage = () => {\n  const handleGoogleLogin = () => {\n    // Redirect to the backend's Google OAuth login endpoint\n    window.location.href = '/auth/google';\n  };\n\n  const handleLogout = () => {\n    // Call the backend API to logout and clear session cookies\n    fetch('/auth/logout', {\n      method: 'POST',\n      credentials: 'include', // Include session cookies\n    })\n      .then((response) => {\n        if (response.ok) {\n          window.location.href = '/'; // Redirect to home page after logout\n        } else {\n          console.error('Logout failed. Please try again.');\n        }\n      })\n      .catch((error) => console.error('Error during logout:', error));\n  };\n\n  return (\n    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', flexDirection: 'column' }}>\n      <h1>Login to Chatbot</h1>\n      <button onClick={handleGoogleLogin} style={{ padding: '10px 20px', fontSize: '16px', cursor: 'pointer', marginBottom: '10px' }}>\n        Login with Google\n      </button>\n      <button onClick={handleLogout} style={{ padding: '10px 20px', fontSize: '16px', cursor: 'pointer' }}>\n        Logout\n      </button>\n    </div>\n  );\n};\n\nexport default AuthPage;\n"}, "src/frontend/pages/ConversationPage.js": {"type": "text-file", "note": "", "contents": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst ConversationPage = () => {\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  const [conversations, setConversations] = useState([]);\n\n  useEffect(() => {\n    // Fetch conversation history\n    const fetchConversations = async () => {\n      try {\n        const response = await axios.get('/api/database/sync'); // Replace with actual endpoint\n        setConversations(response.data.conversations || []);\n      } catch (error) {\n        console.error('Error fetching conversations:', error);\n      }\n    };\n\n    fetchConversations();\n  }, []);\n\n  const handleSendMessage = async () => {\n    if (input.trim()) {\n      setMessages([...messages, { sender: 'user', text: input }]);\n      const userInput = input;\n      setInput('');\n\n      try {\n        // Send the message to the LLM microservice\n        const response = await axios.post('/api/llm/addLLM', { message: userInput });\n\n        if (response.data && response.data.reply) {\n          // Update the UI with the LLM's response\n          setMessages(prevMessages => [\n            ...prevMessages,\n            { sender: 'bot', text: response.data.reply }\n          ]);\n        } else {\n          console.error('Invalid response from LLM microservice');\n        }\n      } catch (error) {\n        console.error('Error communicating with LLM microservice:', error);\n        setMessages(prevMessages => [\n          ...prevMessages,\n          { sender: 'bot', text: 'Error: Unable to get a response from the server' }\n        ]);\n      }\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>\n      <h1>Conversation</h1>\n\n      <div style={{ marginBottom: '20px' }}>\n        <h2>Past Conversations</h2>\n        <ul style={{ border: '1px solid #ccc', padding: '10px', listStyle: 'none', maxHeight: '200px', overflowY: 'auto' }}>\n          {conversations.map((conversation, index) => (\n            <li key={index} style={{ marginBottom: '5px' }}>\n              <span>{conversation.title || `Conversation #${index + 1}`}</span>\n            </li>\n          ))}\n        </ul>\n      </div>\n\n      <div style={{ border: '1px solid #ccc', padding: '10px', height: '400px', overflowY: 'auto', marginBottom: '10px' }}>\n        {messages.map((message, index) => (\n          <div\n            key={index}\n            style={{\n              textAlign: message.sender === 'user' ? 'right' : 'left',\n              margin: '5px 0',\n            }}\n          >\n            <span\n              style={{\n                display: 'inline-block',\n                padding: '10px',\n                borderRadius: '10px',\n                backgroundColor: message.sender === 'user' ? '#d1e7dd' : '#f8d7da',\n                maxWidth: '70%',\n              }}\n            >\n              {message.text}\n            </span>\n          </div>\n        ))}\n      </div>\n\n      <div style={{ display: 'flex' }}>\n        <input\n          type='text'\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          style={{ flex: 1, padding: '10px', fontSize: '16px' }}\n          placeholder='Type your message here...' />\n        <button\n          onClick={handleSendMessage}\n          style={{ padding: '10px 20px', marginLeft: '10px', fontSize: '16px' }}\n        >\n          Send\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default ConversationPage;\n"}, "src/frontend/pages/ConversationPage.js.bak": {"type": "text-file", "note": "", "contents": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst ConversationPage = () => {\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  const [conversations, setConversations] = useState([]);\n\n  useEffect(() => {\n    // Fetch conversation history\n    const fetchConversations = async () => {\n      try {\n        const response = await axios.get('/api/conversations'); // Replace with actual endpoint\n        setConversations(response.data.conversations || []);\n      } catch (error) {\n        console.error('Error fetching conversations:', error);\n      }\n    };\n\n    fetchConversations();\n  }, []);\n\n  const handleSendMessage = async () => {\n    if (input.trim()) {\n      setMessages([...messages, { sender: 'user', text: input }]);\n      const userInput = input;\n      setInput('');\n\n      try {\n        // Send the message to the LLM microservice\n        const response = await axios.post('/api/llm/message', { message: userInput });\n\n        if (response.data && response.data.reply) {\n          // Update the UI with the LLM's response\n          setMessages(prevMessages => [\n            ...prevMessages,\n            { sender: 'bot', text: response.data.reply }\n          ]);\n        } else {\n          console.error('Invalid response from LLM microservice');\n        }\n      } catch (error) {\n        console.error('Error communicating with LLM microservice:', error);\n        setMessages(prevMessages => [\n          ...prevMessages,\n          { sender: 'bot', text: 'Error: Unable to get a response from the server' }\n        ]);\n      }\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>\n      <h1>Conversation</h1>\n\n      <div style={{ marginBottom: '20px' }}>\n        <h2>Past Conversations</h2>\n        <ul style={{ border: '1px solid #ccc', padding: '10px', listStyle: 'none', maxHeight: '200px', overflowY: 'auto' }}>\n          {conversations.map((conversation, index) => (\n            <li key={index} style={{ marginBottom: '5px' }}>\n              <span>{conversation.title || `Conversation #${index + 1}`}</span>\n            </li>\n          ))}\n        </ul>\n      </div>\n\n      <div style={{ border: '1px solid #ccc', padding: '10px', height: '400px', overflowY: 'auto', marginBottom: '10px' }}>\n        {messages.map((message, index) => (\n          <div\n            key={index}\n            style={{\n              textAlign: message.sender === 'user' ? 'right' : 'left',\n              margin: '5px 0',\n            }}\n          >\n            <span\n              style={{\n                display: 'inline-block',\n                padding: '10px',\n                borderRadius: '10px',\n                backgroundColor: message.sender === 'user' ? '#d1e7dd' : '#f8d7da',\n                maxWidth: '70%',\n              }}\n            >\n              {message.text}\n            </span>\n          </div>\n        ))}\n      </div>\n\n      <div style={{ display: 'flex' }}>\n        <input\n          type='text'\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          style={{ flex: 1, padding: '10px', fontSize: '16px' }}\n          placeholder='Type your message here...' />\n        <button\n          onClick={handleSendMessage}\n          style={{ padding: '10px 20px', marginLeft: '10px', fontSize: '16px' }}\n        >\n          Send\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default ConversationPage;\n"}, "src/frontend/assets": {"type": "directory", "note": "", "contents": []}, "src/microservices": {"type": "directory", "note": "", "contents": ["agents", "database", "llm"]}, "src/microservices/agents": {"type": "directory", "note": "", "contents": ["index.js", "routes", "config", "utils"]}, "src/microservices/agents/index.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nrequire('dotenv').config();\nconst healthRouter = require('./routes/health');\nconst managePersonaRouter = require('./routes/managePersona');\n\n// Initialize the Express app\nconst app = express();\n\n// Middleware\napp.use(cors());\napp.use(bodyParser.json());\napp.use(healthRouter);\napp.use(managePersonaRouter);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n    res.status(200).json({ status: 'Agents Service is healthy' });\n});\n\n// Port configuration\nconst PORT = process.env.AGENTS_PORT || 3002;\n\n// Start the server\napp.listen(PORT, () => {\n    console.log(`Agents Microservice is running on port ${PORT}`);\n});\n"}, "src/microservices/agents/routes": {"type": "directory", "note": "", "contents": ["health.js", "managePersona.js", "managePersona.js.bak"]}, "src/microservices/agents/routes/health.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\n\n// Create a new router instance\nconst router = express.Router();\n\n// Define the health check route\nrouter.get('/health', (req, res) => {\n    res.status(200).json({\n        status: 'Agents Microservice is healthy',\n        timestamp: new Date().toISOString()\n    });\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/agents/routes/managePersona.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\n\n// Create a new router instance\nconst router = express.Router();\n\n// In-memory storage for personas (this should use a proper DB in production)\nconst personas = [];\n\n// POST endpoint to create a new persona\nrouter.post('/personas', (req, res) => {\n    const { name, role, description } = req.body;\n\n    if (!name || !role || !description) {\n        return res.status(400).json({ error: 'Missing required fields: name, role, description' });\n    }\n\n    const newPersona = {\n        id: personas.length + 1,\n        name,\n        role,\n        description\n    };\n    personas.push(newPersona);\n    res.status(201).json({ message: 'Persona created successfully', data: newPersona });\n});\n\n// GET endpoint to retrieve all personas\nrouter.get('/personas', (req, res) => {\n    res.status(200).json({ data: personas });\n});\n\n// DELETE endpoint to remove a persona by ID\nrouter.delete('/personas/:id', (req, res) => {\n    const { id } = req.params;\n    const index = personas.findIndex(p => p.id === parseInt(id, 10));\n\n    if (index === -1) {\n        return res.status(404).json({ error: 'Persona not found' });\n    }\n\n    personas.splice(index, 1);\n    res.status(200).json({ message: 'Persona deleted successfully' });\n});\n\n// PUT endpoint to update a persona by ID\nrouter.put('/personas/:id', (req, res) => {\n    const { id } = req.params;\n    const { name, role, description } = req.body;\n\n    if (!name || !role || !description) {\n        return res.status(400).json({ error: 'Missing required fields: name, role, description' });\n    }\n\n    const persona = personas.find(p => p.id === parseInt(id, 10));\n\n    if (!persona) {\n        return res.status(404).json({ error: 'Persona not found' });\n    }\n\n    persona.name = name;\n    persona.role = role;\n    persona.description = description;\n\n    res.status(200).json({ message: 'Persona updated successfully', data: persona });\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/agents/routes/managePersona.js.bak": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\n\n// Create a new router instance\nconst router = express.Router();\n\n// In-memory storage for personas (temporary for development purposes)\nconst personas = [];\n\n// POST endpoint to create a persona\nrouter.post('/personas', (req, res) => {\n    const { name, role, description } = req.body;\n\n    // Validate the request body\n    if (!name || !role || !description) {\n        return res.status(400).json({ error: 'Missing required fields: name, role, description' });\n    }\n\n    // Add the persona to the in-memory list\n    const newPersona = { id: personas.length + 1, name, role, description };\n    personas.push(newPersona);\n\n    // Respond with the created persona\n    return res.status(201).json({ message: 'Persona created successfully', data: newPersona });\n});\n\n// DELETE endpoint to delete a persona by ID\nrouter.delete('/personas/:id', (req, res) => {\n    const { id } = req.params;\n\n    // Find the persona index to remove\n    const index = personas.findIndex(persona => persona.id === parseInt(id, 10));\n\n    if (index === -1) {\n        return res.status(404).json({ error: 'Persona not found' });\n    }\n\n    // Remove the persona from the list\n    personas.splice(index, 1);\n\n    // Respond with a success message\n    return res.status(200).json({ message: 'Persona deleted successfully' });\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/agents/config": {"type": "directory", "note": "", "contents": ["index.js"]}, "src/microservices/agents/config/index.js": {"type": "text-file", "note": "", "contents": "// Placeholder for configuration in Agent Microservice\nmodule.exports = {};\n"}, "src/microservices/agents/utils": {"type": "directory", "note": "", "contents": ["index.js"]}, "src/microservices/agents/utils/index.js": {"type": "text-file", "note": "", "contents": "// Placeholder for utility functions in Agent Microservice\nmodule.exports = {};\n"}, "src/microservices/database": {"type": "directory", "note": "", "contents": ["index.js", "routes", "models", "config", "utils"]}, "src/microservices/database/index.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nrequire('dotenv').config();\nconst syncDatabaseRouter = require('./routes/syncDatabase');\nconst healthRouter = require('./routes/health');\n\n// Initialize the Express app\nconst app = express();\n\n// Middleware\napp.use(cors());\napp.use(healthRouter);\napp.use(bodyParser.json());\napp.use(syncDatabaseRouter);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n    res.status(200).json({ status: 'Database Service is healthy' });\n});\n\n// Port configuration\nconst PORT = process.env.DATABASE_PORT || 3003;\n\n// Start the server\napp.listen(PORT, () => {\n    console.log(`Database Microservice is running on port ${PORT}`);\n});\n"}, "src/microservices/database/routes": {"type": "directory", "note": "", "contents": ["health.js", "syncDatabase.js"]}, "src/microservices/database/routes/health.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\nconst { Sequelize } = require('sequelize');\nconst { MongoClient } = require('mongodb');\n\n// Create a new router instance\nconst router = express.Router();\n\n// Load database configurations\nconst postgresConfig = {\n  host: process.env.POSTGRES_HOST || 'localhost',\n  port: process.env.POSTGRES_PORT || 5432,\n  database: process.env.POSTGRES_DB || 'postgres',\n  username: process.env.POSTGRES_USER || 'user',\n  password: process.env.POSTGRES_PASSWORD || 'password'\n};\n\nconst mongoConfig = {\n  url: process.env.MONGO_URL || 'mongodb://127.0.0.1:27017',\n  dbName: process.env.MONGO_DB_NAME || 'chatbot'\n};\n\n// Health check logic\nconst checkPostgresHealth = async () => {\n  try {\n    const sequelize = new Sequelize(postgresConfig.database, postgresConfig.username, postgresConfig.password, {\n      host: postgresConfig.host,\n      port: postgresConfig.port,\n      dialect: 'postgres',\n      logging: false,\n    });\n    await sequelize.authenticate();\n    await sequelize.close();\n    return { status: 'healthy', message: 'PostgreSQL connection is active' };\n  } catch (error) {\n    return { status: 'unhealthy', message: error.message };\n  }\n};\n\nconst checkMongoHealth = async () => {\n  try {\n    const client = new MongoClient(mongoConfig.url);\n    await client.connect();\n    await client.db(mongoConfig.dbName).command({ ping: 1 });\n    await client.close();\n    return { status: 'healthy', message: 'MongoDB connection is active' };\n  } catch (error) {\n    return { status: 'unhealthy', message: error.message };\n  }\n};\n\n// Define the health check route\nrouter.get('/health', async (req, res) => {\n  const postgresHealth = await checkPostgresHealth();\n  const mongoHealth = await checkMongoHealth();\n  res.status(200).json({\n    postgres: postgresHealth,\n    mongo: mongoHealth\n  });\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/database/routes/syncDatabase.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\nconst { Sequelize } = require('sequelize');\nconst { MongoClient } = require('mongodb');\n\n// Create a new router instance\nconst router = express.Router();\n\n// Define PostgreSQL and MongoDB connection details\nconst postgresConfig = {\n    host: process.env.POSTGRES_HOST || 'localhost',\n    port: process.env.POSTGRES_PORT || 5432,\n    database: process.env.POSTGRES_DB || 'postgres',\n    username: process.env.POSTGRES_USER || 'user',\n    password: process.env.POSTGRES_PASSWORD || 'password'\n};\n\nconst mongoConfig = {\n    url: process.env.MONGO_URL || 'mongodb://127.0.0.1:27017',\n    dbName: process.env.MONGO_DB_NAME || 'chatbot'\n};\n\n// Connect to PostgreSQL\nconst connectPostgres = async () => {\n    const sequelize = new Sequelize(postgresConfig.database, postgresConfig.username, postgresConfig.password, {\n        host: postgresConfig.host,\n        port: postgresConfig.port,\n        dialect: 'postgres',\n    });\n    await sequelize.authenticate();\n    return sequelize;\n};\n\n// Connect to MongoDB\nconst connectMongoDB = async () => {\n    const client = new MongoClient(mongoConfig.url);\n    await client.connect();\n    const db = client.db(mongoConfig.dbName);\n    return { client, db };\n};\n\n// Sync logic for databases\nconst syncDatabases = async () => {\n    const postgres = await connectPostgres();\n    const mongo = await connectMongoDB();\n    const mongoClient = mongo.client;\n    const mongoDb = mongo.db;\n    \n    try {\n        console.log('Fetching data from PostgreSQL...');\n        const [users] = await postgres.query('SELECT * FROM users');\n        console.log('Fetched users:', users.length);\n\n        console.log('Syncing data with MongoDB...');\n        await mongoDb.collection('users').deleteMany({});\n        await mongoDb.collection('users').insertMany(users.map((user) => ({\n            username: user.username,\n            email: user.email,\n            createdAt: user.createdAt,\n            updatedAt: user.updatedAt\n        })));\n        \n        console.log('Sync complete!');\n        return {\n            message: 'Databases synced successfully',\n            postgres: users.length,\n            mongo: await mongoDb.collection('users').countDocuments()\n        };\n    } finally {\n        await postgres.close();\n        await mongoClient.close();\n    }\n};\n\n// Define the sync database route\nrouter.post('/syncDatabase', async (req, res) => {\n    try {\n        const result = await syncDatabases();\n        res.status(200).json({\n            status: 'success',\n            message: result.message,\n            postgresCount: result.postgres,\n            mongoCount: result.mongo\n        });\n    } catch (error) {\n        console.error('Error syncing databases:', error);\n        res.status(500).json({\n            status: 'error',\n            message: 'Failed to sync databases',\n            error: error.message\n        });\n    }\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/database/models": {"type": "directory", "note": "", "contents": ["UserModel.js", "ConversationLogModel.js"]}, "src/microservices/database/models/UserModel.js": {"type": "text-file", "note": "", "contents": "'use strict';\n\nconst { DataTypes, Model } = require('sequelize');\nconst sequelize = require('../config/database'); // Assumes a database config file exists\n\nclass User extends Model {}\n\nUser.init(\n  {\n    id: {\n      type: DataTypes.INTEGER,\n      autoIncrement: true,\n      primaryKey: true,\n    },\n    username: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      unique: true,\n    },\n    email: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      unique: true\n    },\n    password: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    createdAt: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n    },\n    updatedAt: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n    },\n  },\n  {\n    sequelize,\n    modelName: 'User',\n    tableName: 'users',\n    timestamps: true,\n  }\n);\n\nmodule.exports = User;\n"}, "src/microservices/database/models/ConversationLogModel.js": {"type": "text-file", "note": "", "contents": "'use strict';\n\nconst { DataTypes, Model } = require('sequelize');\nconst sequelize = require('../config/database'); // Adjust path if config file differs\n\nclass ConversationLog extends Model {}\n\nConversationLog.init(\n  {\n    id: {\n      type: DataTypes.INTEGER,\n      autoIncrement: true,\n      primaryKey: true,\n    },\n    conversationId: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    sender: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    message: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    createdAt: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n    },\n    updatedAt: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n    },\n  },\n  {\n    sequelize,\n    modelName: 'ConversationLog',\n    tableName: 'conversation_logs',\n    timestamps: true,\n  }\n);\n\nmodule.exports = ConversationLog;\n"}, "src/microservices/database/config": {"type": "directory", "note": "", "contents": ["index.js"]}, "src/microservices/database/config/index.js": {"type": "text-file", "note": "", "contents": "// Placeholder for configurations in Database Microservice\nmodule.exports = {};\n"}, "src/microservices/database/utils": {"type": "directory", "note": "", "contents": ["index.js"]}, "src/microservices/database/utils/index.js": {"type": "text-file", "note": "", "contents": "// Placeholder for utilities in Database Microservice\nmodule.exports = {};\n"}, "src/microservices/llm": {"type": "directory", "note": "", "contents": ["index.js", "routes", "config", "tests", "utils"]}, "src/microservices/llm/index.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst config = require('./config');\nconst log = require('./utils/logger');\nrequire('dotenv').config();\nconst addLLMRouter = require('./routes/addLLM');\n\n// Initialize the Express app\nconst app = express();\n\n// Middleware\napp.use(cors());\napp.use(bodyParser.json());\napp.use(addLLMRouter);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  log('Health endpoint accessed');\n  res.status(200).json({ status: 'LLM Service is healthy' });\n});\n\n// Port configuration\nconst PORT = config.port;\n\n// Start the server\napp.listen(PORT, () => {\n  log(`LLM Microservice is running on port ${PORT}`);\n});\n"}, "src/microservices/llm/routes": {"type": "directory", "note": "", "contents": ["health.js", "addLLM.js"]}, "src/microservices/llm/routes/health.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\n\n// Create a new router instance\nconst router = express.Router();\n\n// Define the health check route\nrouter.get('/health', (req, res) => {\n    res.status(200).json({ status: 'LLM Microservice is healthy' });\n});\n\n// Export the router\nmodule.exports = router;\n"}, "src/microservices/llm/routes/addLLM.js": {"type": "text-file", "note": "", "contents": "// Import required dependencies\nconst express = require('express');\n\n// Create a new router instance\nconst router = express.Router();\nconst axios = require(\"axios\");\n\n// In-memory store for LLM configurations (temporary for development purposes)\nconst llmConfigurations = [];\n\n// POST route to add a new LLM configuration\nrouter.post('/addLLM', (req, res) => {\n    const { name, apiKey, endpoint } = req.body;\n\n    // Validate request body\n    if (!name || !apiKey || !endpoint) {\n        return res.status(400).json({ error: 'Missing required fields: name, apiKey, endpoint' });\n    }\n\n    // Save to the in-memory store\n    llmConfigurations.push({ name, apiKey, endpoint });\n\n    // Respond with success\n    return res.status(201).json({ message: 'LLM configuration added successfully', data: { name, apiKey, endpoint } });\n});\n\n// GET route to list all LLM configurations\nrouter.get('/listLLM', (req, res) => {\n    // Respond with the current list of LLM configurations\n    res.status(200).json({\n        message: 'List of configured LLMs retrieved successfully',\n        data: llmConfigurations\n    });\n});\n\n// Export the router\nmodule.exports = router;\n\n// GET route to check the health of external LLM APIs\nrouter.get('/llmHealth', async (req, res) => {\n    const results = [];\n    for (const llm of llmConfigurations) {\n        try {\n            const response = await axios.get(llm.endpoint, {\n                headers: { 'Authorization': `Bearer ${llm.apiKey}` }\n            });\n            results.push({ name: llm.name, status: 'healthy', details: response.data });\n        } catch (error) {\n            results.push({ name: llm.name, status: 'unhealthy', error: error.message });\n        }\n    }\n    res.status(200).json({\n        message: 'LLM health check completed',\n        results\n    });\n});\n\n"}, "src/microservices/llm/config": {"type": "directory", "note": "", "contents": ["index.js"]}, "src/microservices/llm/config/index.js": {"type": "text-file", "note": "", "contents": "// Configuration setup for LLM Microservice\n\nconst dotenv = require('dotenv');\ndotenv.config();\n\nmodule.exports = {\n  port: process.env.LLM_PORT || 3001,\n  apiKey: process.env.LLM_API_KEY || '',\n  apiEndpoint: process.env.LLM_API_ENDPOINT || '',\n  defaultLLM: process.env.DEFAULT_LLM || 'AzureOpenAI',\n};\n\n"}, "src/microservices/llm/tests": {"type": "directory", "note": "", "contents": ["llmRoutes.test.js"]}, "src/microservices/llm/tests/llmRoutes.test.js": {"type": "text-file", "note": "", "contents": "const request = require('supertest');\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\n// Mock LLM microservice routes\nconst addLLMRouter = require('../routes/addLLM');\nconst healthRouter = require('../routes/health');\n\n// Create a test app\nconst app = express();\napp.use(bodyParser.json());\napp.use(addLLMRouter);\napp.use(healthRouter);\n\ndescribe('LLM API Routes', () => {\n  test('Health endpoint should return 200 with correct status message', async () => {\n    const response = await request(app).get('/health');\n    expect(response.status).toBe(200);\n    expect(response.body).toHaveProperty('status', 'LLM Microservice is healthy');\n  });\n\n  test('POST /addLLM should add a new LLM configuration', async () => {\n    const llmConfig = {\n      name: 'test-llm',\n      apiKey: 'test-api-key',\n      endpoint: 'https://sample-endpoint.com'\n    };\n    const response = await request(app).post('/addLLM').send(llmConfig);\n    expect(response.status).toBe(201);\n    expect(response.body.message).toBe('LLM configuration added successfully');\n    expect(response.body.data).toMatchObject(llmConfig);\n  });\n\n  test('POST /addLLM should return 400 for missing fields', async () => {\n    const response = await request(app).post('/addLLM').send({ name: 'test-llm' });\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('Missing required fields: name, apiKey, endpoint');\n  });\n});\n"}, "src/microservices/llm/utils": {"type": "directory", "note": "", "contents": ["logger.js"]}, "src/microservices/llm/utils/logger.js": {"type": "text-file", "note": "", "contents": "// Placeholder for utility functions\nfunction log(message) {\n  console.log(`[LLM Service] ${message}`);\n}\n\nmodule.exports = log;\n"}, "src/middleware": {"type": "directory", "note": "", "contents": ["auth.js"]}, "src/middleware/auth.js": {"type": "text-file", "note": "", "contents": "// Import dependencies\nconst jwt = require('jsonwebtoken');\nrequire('dotenv').config();\n\n// Middleware function to validate JWT tokens\nconst authenticateJWT = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token is missing' });\n  }\n\n  // Verify the provided token\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid or expired token' });\n    }\n    req.user = user; // Attach decoded user information to the request\n    next();\n  });\n};\n\n// Export the middleware\nmodule.exports = authenticateJWT;\n"}, ".env.example": {"type": "text-file", "note": "", "contents": "# Environment variables required for the application\n\n# JWT secret for token authentication\nJWT_SECRET=your-secret-key\n\n# Database connection string\nDATABASE_URL=postgres://username:password@localhost:5432/database_name\n\n# Azure OpenAI API key and endpoint\nLLM_API_KEY=your-azure-openai-api-key\nLLM_API_ENDPOINT=https://your-azure-openai-endpoint.com\n\n# Microservice-specific ports\nLLM_PORT=3001\nAGENTS_PORT=3002\nDATABASE_PORT=3003\n\n# OAuth2 secret for user authentication\nOAUTH2_SECRET=your-oauth2-secret\n\n# Default LLM configuration\nDEFAULT_LLM=AzureOpenAI\n\n# Additional environment-specific configurations if needed\n"}, "README.md": {"type": "text-file", "note": "", "contents": "```markdown\n# Multi-Agent Software Development System\n\nA state-of-the-art collaborative platform that orchestrates multiple specialized software agents to simplify and automate various stages of software development. This system accelerates software creation, testing, deployment, database synchronization, user authentication, and even updates its own documentation. It is designed to boost developer productivity with modularity, scalability, and seamless integration between its components.\n\n---\n\n## Features\n\n- **Multi-Agent Architecture**:  \n  Utilizes specialized agents to handle distinct development tasks, enabling scalability and modularity.\n\n- **Frontend ConversationPage Revamp**:  \n  - Enhanced `src/frontend/pages/ConversationPage.js` to use actual APIs for conversation handling.  \n  - Integrated endpoints for synchronizing conversation logs and interacting with the LLM microservice.\n\n- **Google OAuth Integration**:  \n  - Secure, user-friendly login/logout functionality with Google OAuth, implemented in the frontend `AuthPage.js`.\n\n- **LLM Microservice**:  \n  - Configurable integration with AI models like Azure OpenAI.  \n  - Includes health-check endpoints and dynamic endpoint management.\n\n- **Persona Management API**:  \n  - CRUD functionality for creating, managing, and deleting personas.  \n  - Dynamically adjust agent behaviors based on persona configurations.\n\n- **Database Synchronization**:  \n  - Enables seamless synchronization between PostgreSQL and MongoDB databases.  \n  - Includes an SQL-based `conversation_logs` table to capture API-driven chat logs.\n\n- **Robust Health Monitoring**:  \n  - Monitors availability of key services via `/health` endpoints.\n\n- **JWT Authentication Middleware**:  \n  - Token validation for secure API communication and resource protection.\n\n- **Customizable Configuration**:  \n  - Environment variable-driven setup for authentication secrets, LLM endpoints, database connections, and more.\n\n- **Solid Developer Tooling**:  \n  - Includes workflows for testing (`npm test`), linting (`npm run lint`), and building (`npm run build`) to ensure maintainable code.\n\n---\n\n## Recent Changes\n\n### 1. Improved ConversationPage UI (Task: #15)  \nEnhanced the `ConversationPage.js` to fetch and send user messages using actual backend APIs. Integrated the following endpoints:  \n- **Conversation API**: Redirected to `/api/database/sync` for synchronizing conversation data with the database.  \n- **LLM Message API**: Redirected to `/api/llm/addLLM` for LLM-based user interaction.\n\nExample Component Update:\n```jsx\nfetch('/api/database/sync')\n  .then(response => response.json())\n  .then(data => console.log(data));\n\nfetch('/api/llm/addLLM', {\n  method: 'POST',\n  body: JSON.stringify({ message: userMessage }),\n  headers: { 'Content-Type': 'application/json' }\n})\n  .then(response => response.json())\n  .then(result => console.log(result));\n```\n\n---\n\n### 2. Google OAuth Integration  \nSecure Google login/logout capability introduced in `AuthPage.js`. \n\nExample buttons:\n```jsx\n<div>\n  <button onClick={handleGoogleLogin}>Login with Google</button>\n  <button onClick={handleLogout}>Logout</button>\n</div>\n```\n\n---\n\n### 3. Persona Management API  \nCRUD API for managing configurable personas:\n```bash\n# Create a persona\ncurl -X POST http://localhost:<AGENTS_PORT>/personas \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\": \"Developer\", \"role\": \"Backend Engineer\", \"description\": \"Handles API design\"}'\n\n# Retrieve all personas\ncurl http://localhost:<AGENTS_PORT>/personas\n```\n\n---\n\n## Setup & Installation\n\n### Prerequisites\nEnsure the following dependencies are installed:\n- **Node.js v18+**  \n- **PostgreSQL** (running instance)  \n- **MongoDB** (running instance)  \n- A Google OAuth Client (`Client ID` and `Client Secret`).  \n\n### Installation Steps\n\n1. Clone the repository:\n   ```bash\n   git clone https://github.com/your-organization/multi-agent-development-system.git\n   cd multi-agent-development-system\n   ```\n\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Configure the `.env` file:\n   ```bash\n   cp .env.example .env\n   ```\n   Fill in values like `JWT_SECRET`, `DATABASE_URL`, `GOOGLE_CLIENT_ID`, etc.\n\n4. Set up databases:\n   Ensure PostgreSQL and MongoDB services are running, then initialize the database structures:\n   ```bash\n   npx sequelize-cli db:migrate\n   ```\n\n---\n\n## Running the Application\n\nStart the main application:\n```bash\nnpm run start\n```\n\nThis will initialize the frontend, backend microservices, and database sync functionalities.\n\n### Example API Interactions\n1. **Login via Google OAuth**  \n   Visit the UI at `http://localhost:<FRONTEND_PORT>` and click \"Login with Google.\"\n\n2. **Synchronize Conversations**:  \n   ```bash\n   curl -X POST http://localhost:<AGENTS_PORT>/syncDatabase\n   ```\n\n3. **Check Microservice Health**:  \n   ```bash\n   curl http://localhost:<AGENTS_PORT>/health\n   ```\n\n---\n\n## Configuration\n\n### Required Environment Variables\n\nBelow are the key environment variables required to configure the system:\n\n| Variable                | Description                                     |\n|-------------------------|-------------------------------------------------|\n| `JWT_SECRET`            | Secret key for secure JWT authentication.       |\n| `DATABASE_URL`          | PostgreSQL connection string.                  |\n| `LLM_API_KEY`           | API key for Azure OpenAI Service integration.  |\n| `LLM_API_ENDPOINT`      | URL endpoint for Azure OpenAI service.         |\n| `LLM_PORT`              | Running port for the LLM microservice.         |\n| `AGENTS_PORT`           | Running port for the agents microservice.      |\n| `GOOGLE_CLIENT_ID`      | OAuth client ID for Google authentication.     |\n| `GOOGLE_CLIENT_SECRET`  | OAuth client secret for Google authentication. |\n| `POSTGRES_HOST`         | PostgreSQL instance hostname.                  |\n| `POSTGRES_PORT`         | PostgreSQL port number.                        |\n| `POSTGRES_USER`         | User for accessing PostgreSQL.                 |\n| `POSTGRES_PASSWORD`     | PostgreSQL account password.                   |\n| `POSTGRES_DB`           | Target database in PostgreSQL.                 |\n| `MONGO_URL`             | Connection string for MongoDB.                 |\n| `MONGO_DB_NAME`         | Target database in MongoDB.                    |\n\n---\n\n## Developer Workflows\n\n### Testing\nRun the test suite:\n```bash\nnpm test\n```\n\n### Code Linting\nEnsure clean code with lint checks:\n```bash\nnpm run lint\n```\n\n### Build for Production\nGenerate a production-ready build:\n```bash\nnpm run build\n```\n\n---\n\n## Contributing\n\nContributions are welcomed! To contribute:\n1. Fork the repository and create a feature branch (e.g., `feature/new-feature-x`).  \n2. Follow coding and documentation standards, ensuring all tests pass.  \n3. Open a pull request and provide a detailed description of your changes.  \n\nRefer to the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines.\n\n---\n\n## License\n\nThis project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.\n```"}}